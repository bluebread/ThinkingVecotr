<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<link type="text/css" rel="stylesheet" href="demoStyle.css" type="text/css">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.11.4/paper-full.js"></script>
<style type="text/css">
	canvas{
		width: 100%;
		height: 120%;
		background: #FFEEEE;  /* fallback for old browsers */
		background: -webkit-linear-gradient(to right, #DDEFBB, #FFEEEE);  /* Chrome 10-25, Safari 5.1-6 */
		background: linear-gradient(to right, #DDEFBB, #FFEEEE); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */

	}
	.navbar{
		background-color: #F5F5DC;
	    margin: 0 auto;
	}
	.fa{
		font-size: 2em;
	}
	.footer {
		display: block;
	    color: #777;
		background: #F5F5DC;
	}
	footer p{
		margin: 0 auto;
	}
	body{
		margin-bottom: 10px;
		background-color: #F5F5DC;
	}
</style>

</head>
<body>


<nav class="navbar navbar-toggleable-md navbar-light bg-faded">
  <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <i class="fa fa-paper-plane" aria-hidden="true"></i>
  <a class="navbar-brand" href="#">Thinking Vector</a>
  <div class="collapse navbar-collapse" id="navbarNavDropdown">
    <ul class="navbar-nav">
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="http://example.com" id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
          Vectors
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
          <a class="dropdown-item" id="BV" href="#">Because</a>
          <a class="dropdown-item" id="LTV" href="#">Lead To</a>
          <a class="dropdown-item" id="NV" href="#">Not</a>
          <a class="dropdown-item" id="EIV" href="#">Else If</a>
        </div>
      </li>
    </ul>
  </div>
</nav>

<script type="text/paperscript" canvas="myCanvas">
{};
var clickStartPoint,
	clickEndPoint,
	myCircle,
	myDashLine,
	arrowStroke,
	arrowPath,
	horizonDashLine,
	verticalDashLine,
	sinPath;
var whichVector = "BecauseVector";

var myRadius = 25;
var circleColor = '#0000FF';
var arrowColor = '#1E90FF';
var circleBusy = false;
var circleEnter = true;
var arrayDash = [];

var circleGroup = new Group();
var arrowStrokeGroup = new Group();
var arrowPathGroup = new Group();
var dashGroup = new Group;
var sinPathGroup = new Group;

var point1 = new Point(200, 200);
var point2 = new Point(800, 400);

// setLeadToVector(point1, point2);
// createArrow(point1, point2, 'black');

GroupsInsertBelow();
vecBottomListener();

function onMouseDown(event) {
	if (!circleBusy) {
		clickStartPoint = event.point;
		creatCircle(event.point, myRadius, circleColor);
	}
}
function GroupsInsertBelow(){
	arrowPathGroup.insertBelow(circleGroup);
	sinPathGroup.insertBelow(arrowPathGroup);
	arrowStrokeGroup.insertBelow(sinPathGroup);
	dashGroup.insertBelow(arrowStrokeGroup);	
}
function vecBottomListener(){
	$("#BV").click(function(event) {
		console.log("BV CONNECTED!")
		whichVector = 'BecauseVector';
	});
	$("#LTV").click(function(event) {
		console.log("LV CONNECTED!")
		whichVector = 'LeadToVector';
	});
	$("#NV").click(function(event) {
		console.log("NV CONNECTED!")
		whichVector = 'NotVector';
	});
	$("#EIV").click(function(event) {
		console.log("EIV CONNECTED!")
		whichVector = 'ElseIfVector';
	});
}
function chooseVector(circleCenter, mousePoint){
	if (whichVector === 'BecauseVector') {
		console.log(circleCenter);
		setBecVector(circleCenter, mousePoint, arrowColor);
		arrowStroke.removeOnDrag();
		arrowPath.removeOnDrag();
	}else if(whichVector === 'LeadToVector'){
		creatSinGraph(circleCenter, mousePoint);
		sinPath.removeOnDrag();
	}else if(whichVector === 'NotVector'){
		return null;
	}else if(whichVector === 'ElseIfVector'){
		return null;
	}else{
		return undefined;
	}
}

//set circle to listen lots of events
Path.prototype.circleListener = function(){
	// When the mouse enters the item, set its fill color to red:
	this.onMouseEnter = function(event) {
		this.fillColor = '#00BFFF';
		circleBusy = true;
	}
	// When the mouse leaves the item, set its fill color to black:
	this.onMouseLeave = function(event) {
	    this.fillColor = circleColor;
	    circleBusy = false;
	}

	this.onMouseDrag = function(event){
		if (!circleBusy) {
			chooseVector(this.data.center, event.point);
			creatDash(this.data.center, event.point);
			horizonDashLine.removeOnDrag();
			// verticalDashLine.removeOnDrag();			
		}
	}
	this.onMouseUp = function(event){
		if(horizonDashLine){
			horizonDashLine.opacity = 0;
		}
	}
}
Path.prototype.dashLineListener = function() {
	// When the mouse enters the item, set its fill color to red:
	this.onMouseEnter = function(event) {
	    this.opacity = 0.7;
	}
	// When the mouse leaves the item, set its fill color to black:
	this.onMouseLeave = function(event) {
	    this.opacity = 0;
	}
};


//The part of dash line
function creatDash(center, endPoint) {
	var horizonVector = endPoint - center;
	var verticalVector = new Point(-horizonVector.y, horizonVector.x);
	// vertical line
	// verticalDashLine = new Path();
	// drawMathFuncByVector(horizonVector, endPoint, verticalDashLine);
	// verticalDashLine.dashLineListener();
	// verticalDashLine.strokeWidth = 3;
	// verticalDashLine.strokeColor = arrowColor;

	//hrorizon line
	horizonDashLine = new Path();
	drawMathFuncByVector(verticalVector, endPoint, horizonDashLine);
	horizonDashLine.strokeWidth = 4;
	horizonDashLine.strokeColor = 'gray';
	horizonDashLine.dashArray = [10, 12];

	horizonDashLine.dashLineListener();
	horizonDashLine.insertBelow(arrowStroke);

	dashGroup.addChild(horizonDashLine);
}


function drawMathFuncByVector(vector, point, line) {
	var A = vector.x,
		B = vector.y;
	for (var dashX = 0 ; dashX < 1300; dashX++) {
		var dashY = ((-A) / B) * (dashX - point.x) + point.y;
		var dashPoint = new Point(dashX, dashY);
		line.add(dashPoint);
	}
}

//The part of 'Because Vector'
function creatCircle(center, radius, color){
	myCircle = new Path.Circle(center, radius);
	myCircle.fillColor = color;
	myCircle.data.center = center;
	myCircle.circleListener();

	circleGroup.addChild(myCircle);
}
function creatStroke(startPoint, endPoint, color){
	var myVec = endPoint - startPoint;
	arrowStroke = new Path(startPoint, endPoint);
	arrowStroke.strokeColor = color;
	//set the width of arrow stroke
	var arrowStrokeWidth = myVec.length / 40;
	var maxArrowStrokeWidth = 10;
	var minArrowStrokeWidth = 4;
	arrowStroke.strokeWidth = arrowStrokeWidth;
	if(arrowStrokeWidth > maxArrowStrokeWidth) {
		arrowStroke.strokeWidth = maxArrowStrokeWidth;
	}else if(arrowStrokeWidth < minArrowStrokeWidth){
		arrowStroke.strokeWidth = minArrowStrokeWidth;
	}

	// arrowStroke.strokeWidth = 4;
	arrowStroke.insertBelow(myCircle);

	arrowStrokeGroup.addChild(arrowStroke);
}
function createArrow(startPoint, endPoint, color){
	//magic number
	var shortenParam = 0.1;
	//create arrow line
	var myRevVec = -(endPoint - startPoint);//reverse vector
	var myRevShortVec = myRevVec * shortenParam;
	//restrict the length of arrow path
	var maxArrowPath = 30;
	if (myRevShortVec > maxArrowPath) {
		myRevShortVec /= myRevShortVec.length;
		myRevShortVec *= maxArrowPath;
	}
	//create right arrow line
	var rightVec = myRevShortVec.clone();
	var leftVec = myRevShortVec.clone();
	//rotate the angle
	rightVec.angle += 30;
	leftVec.angle -= 30;

	var rightEnd = endPoint + rightVec,
		leftEnd  = endPoint + leftVec;
	var segments = [rightEnd, endPoint, leftEnd];
	//create arrow
	arrowPath = new Path(segments);
	//set the width of arrow
	var arrowWidth = myRevVec.length / 40;
	var maxArrowWidth = 12;
	var minArrowWidth = 3;
	arrowPath.strokeWidth = arrowWidth;
	
	if (arrowWidth > maxArrowWidth) {
		arrowPath.strokeWidth = maxArrowWidth;
	}else if(arrowWidth < minArrowWidth){
		arrowPath.strokeWidth = minArrowWidth;
	}

	arrowPath.strokeColor = arrowColor;

	arrowPathGroup.addChild(arrowPath);
}
function setBecVector(circleCenter, arrowEnd, color) {
	creatStroke(circleCenter, arrowEnd, color);
	createArrow(circleCenter, arrowEnd, color);
}

//The Part of 'LeadTo Vector'
function creatSinGraph(startPoint, endPoint){
	var sinPathVector = endPoint - startPoint;
	sinPath = new Path();
	//magic numbers
	var height = 10,
		wavelength = 18,
		timeOfWave = sinPathVector.length/18,
		radian_degree_rate = Math.PI / 360,
		unitOfSinX = 50,
		telescopeSinX = 20;
	for (var sinX = 0; sinX < 360 * timeOfWave; sinX += unitOfSinX) {
		var radian = sinX * radian_degree_rate;//trun degree to radian
		var sinY = Math.sin(radian) * height;
		var sinPoint = new Point(sinX / telescopeSinX, sinY);
		sinPoint.angle += sinPathVector.angle;
		sinPoint += startPoint;
		sinPath.add(sinPoint);
	}
	sinPath.smooth();
	// sinPath.fullySelected = true;
	sinPath.strokeColor = arrowColor;
	sinPath.strokeWidth = 3;

	sinPathGroup.addChild(sinPath);
}
function setLeadToVector(center1, center2) {
	// set a 'LeadTo Vector'
	//magic numbers
	var whiteSpace = 1/6,
		shortenRate = 4/6;
	//vector
	var vector1to2 = center2 - center1;
	var shortenVec = vector1to2;
	shortenVec.length *= shortenRate;
	//startPoint
	var lineStart = center1 + vector1to2 * whiteSpace;
	var lineEnd = lineStart + shortenVec;

	creatSinGraph(lineStart, lineEnd);
}
</script>
<canvas id="myCanvas" resize="true"></canvas>
<footer class="footer">
	<p>© BlueBread 2017</p>
</footer>
</body>
</html>
